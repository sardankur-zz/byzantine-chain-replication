from nacl.bindings.utils import sodium_memcmp
import logging
import nacl.signing
import nacl.hash
import nacl.encoding
import time

HASHER = nacl.hash.sha256
get_logger = import_da("app_logging").get_logger
common = import_da("common")
Failure = import_da("failure").Failure

OpArgs = common.OpArgs
OrderStatement = common.OrderStatement
ResultStatement = common.ResultStatement
Shuttle = common.Shuttle
ResultShuttle = common.ResultShuttle
Operation = common.Operation
Config = common.Config
ReplicaState = common.ReplicaState

logger = get_logger("REPLICA")

class Replica(process):
    

    def setup(head_timeout: int, nonhead_timeout: int, rid: int, replicas, private_key, public_keys, failures):
        self.on = True
        self.slot_number = -1 # so that number starts from zero
        self.dictionary = {}
        self.resultShuttleCache = {}
        self.retransmitCache = {}
        self.requestCache = {}

        self.rnum = len(replicas)
        self.nextr = replicas[rid + 1] if (rid < rnum-1) else None
        self.prevr = replicas[rid - 1] if (rid > 0 ) else None
        self.head  = replicas[0]

        # tracking of message
        self.client_requests = {}
        self.client_forward_requests = {}
        self.shuttle_requests = {}
        self.result_shuttle_requests = {}

        # set logging
        formatter = logging.Formatter("%(asctime)s : %(levelname)s : %(name)s " + str(self.rid) + " : %(message)s")
        for handler in logger.handlers:
            handler.setFormatter(formatter)

        logger.info("Initialized")

    def run():
        logger.info("Running")
        await(self.on == False)
        logger.info("Terminated")


    def creatSignedOrderStatement(slot_number, opArgs):
        orderStatement = str(slot_number) + str(opArgs)
        orderStatement = orderStatement.encode(encoding='UTF-8')
        signature = private_key.sign(orderStatement)
        return OrderStatement(self.slot_number, opArgs, signature)


    def creatSignedResultStatement(opArgs, result):
        result_hash = HASHER(result.encode(encoding='UTF-8'), encoder=nacl.encoding.HexEncoder)
        resultStatement = str(opArgs).encode(encoding='UTF-8') + result_hash
        signature = private_key.sign(resultStatement)
        return ResultStatement(opArgs, result_hash, signature)


    def incr(tracker, cid):
        if tracker.get(str(cid), None) is None:
           tracker[str(cid)] = 1
        else:
            tracker[str(cid)] = tracker[str(cid)] + 1


    def get(tracker, cid):
        return tracker.get(str(cid), 0)


    def isOrderProofValid(slot_number, opArgs, order_proof):
        i = 0
        for orderStatement in order_proof:
            if orderStatement is None:
                logger.debug("Order Statement number = %d is missing" % i)
                return False
            if orderStatement.slot_number != slot_number:
                logger.debug("Slot number for Order Statement number = %d is not correct" % i)
                return False
            if orderStatement.operation != opArgs:
                logger.debug("opArgs for Order Statement number = %d is not valid" % i)
                return False
            try:
                self.public_keys[i].verify(orderStatement.signature)
            except Exception:
                logger.debug("Order Statement number = %d is tempered" % i)
                return False   
            i = i + 1
            
        return True

    
    def isvalidResultProof(opArgs, result, result_proof, public_keys):
        result_hash = HASHER(result.encode(encoding='UTF-8'), encoder=nacl.encoding.HexEncoder)
        i = 0

        for resultStatement in result_proof:
            if resultStatement is None:
                logger.debug("Result statement number = %d is missing" % i)
                return False   
            if opArgs != resultStatement.operation:
                logger.debug("opArgs for Result statement number = %d is not valid" % i)
                return False         
            if not sodium_memcmp(resultStatement.result_hash, result_hash):
                logger.debug("Result Hash for Result statement number = %d is not valid" % i)
                return False

            try:
                public_keys[i].verify(resultStatement.signature)
            except Exception:
                logger.debug("Result Statement number = %d is tempered" % i)
                return False
            i = i + 1

        return True 

    def receive(msg=('client_request', opArgs, cid, requestIndex), from_=p):
        logger.info("Client request from cid = %d requestId = %d received with op args %s" % (cid, requestIndex, opArgs))

        self.slot_number = self.slot_number + 1;

        # change opArgs if failure case demands
        failure = Failure.get_failure(failures, 'client_request', self.get(self.client_requests, cid), cid, 'change_operation')
        if(len(failure) > 0):
            opArgs = Failure.change_operation()
        
        # store received operations in the cache
        requestCache[(cid, requestIndex)] = opArgs

        shuttle = Shuttle(self.slot_number, opArgs, p, cid, requestIndex)

        result = Operation.do_op(dictionary, opArgs)

        # change result if applicable
        failure = Failure.get_failure(failures, 'client_request', self.get(self.client_requests, cid), cid, 'change_result')
        if (len(failure) > 0):
            result = Failure.change_result()

        orderStatement = creatSignedOrderStatement(self.slot_number, opArgs)
        shuttle.order_proof.append(orderStatement)

        resultStatement = creatSignedResultStatement(opArgs, result)
        shuttle.result_proof.append(resultStatement)

        # change opArgs if failure case demands
        failure = Failure.get_failure(failures, 'client_request', self.get(self.client_requests, cid), cid, 'drop_result_stmt')
        if (len(failure) > 0):
            shuttle.result_proof[0] = None

        logger.info("Shuttle Started\t\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(shuttle.cid, shuttle.requestIndex, shuttle.slot_number))
        send(('shuttle', shuttle), to=nextr)

        self.incr(self.client_requests, cid)


    def receive(msg=('client_retransmit_request', opArgs, cid, requestIndex), from_=p) :
        
        logger.info("Received Retransmit request for opArgs = %s cid = %d requestIndex = %d" % (opArgs, cid, requestIndex))
        
        # send from result cache if available 
        resultShuttle = resultShuttleCache.get((cid, requestIndex), None);
        if resultShuttle is not None:
            if rid == 0:
                retransmitCache[(cid,requestIndex)] = 'Responded'

            logger.info("Replying to retransmit request from resultCache. cid = %d and requestIndex = %d" % (cid, requestIndex))   
            send(('client_retransmit_response', resultShuttle.result, resultShuttle.result_proof, resultShuttle.requestIndex), to=p)
            return 
        
        # otherwise forward request to head (even if this request is at head)       
        logger.info('Forwarding request to head for cid = %d requestIndex = %d' % (cid, requestIndex))
        send(('client_request_forward', opArgs, cid, requestIndex, rid), to=head)

        # start a timer if not head
        if(rid != 0):
            if(await(some(received(('head_responded_to_retransmit', cid1, requestIndex1)), has=(requestIndex1 == requestIndex and cid1 == cid)))):    
                
                logger.info('Head responded to retransmit request for cid = %d requestIndex = %d' % (cid, requestIndex))
                resultShuttle = resultShuttleCache.get((cid, requestIndex), None);

                if resultShuttle is not None: # this can still have result as none (unlikely), in that case the replica should reconfigure
                    logger.info("Replying to retransmit request from cid = %d and requestIndex = %d" % (cid, requestIndex))
                    send(('client_retransmit_response', resultShuttle.result, resultShuttle.result_proof, resultShuttle.requestIndex), to=p)
                else:
                    logger.error('Reconfigure: client_retransmit_request empty cache on confiramtion receipt cid = %d and requestIndex = %d' % (cid, requestIndex))

            elif timeout(nonhead_timeout):
                logger.error('Reconfigure: Client_request_forward timeout cid = %d and requestIndex = %d' % (cid, requestIndex))
                
   


    # Only For Head 
    def receive(msg=('client_request_forward', opArgs, cid, requestIndex, sourceRid), from_=p):
        
        logger.info("Received Forwarded request for cid = %d requestIndex = %d from rid = %d" % (cid, requestIndex, sourceRid))

        #if this is first forwarded request received at the head
        if retransmitCache.get((cid, requestIndex), None) is None:
            retransmitCache[(cid, requestIndex)] = 'inProcess'
            
            logger.info("Processing Forwarded request for cid = %d requestIndex = %d from rid = %d" % (cid, requestIndex, sourceRid))

            # change result cache for un-recognized op
            failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid),
                                          cid, 'remove_from_cache')
            if (len(failure) > 0):
                if (cid, requestIndex) in resultShuttleCache.keys():
                    resultShuttleCache.pop((cid, requestIndex))
                if (cid, requestIndex) in requestCache.keys():
                    requestCache.pop((cid, requestIndex))

            # send from result cache if available 
            resultShuttle = resultShuttleCache.get((cid, requestIndex), None);
            if resultShuttle is not None:

                # change result if applicable
                failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid), cid,
                                              'change_result')
                if (len(failure) > 0):
                    resultShuttle.result = Failure.change_result()

                    # change result if applicable
                    failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid),
                                                  cid,
                                                  'change_result')
                    if (len(failure) > 0):
                        resultShuttle.result = Failure.change_result()


                    # change opArgs if failure case demands
                    failure = Failure.get_failure(failures, 'forwarded_request',
                                                  self.get(self.client_requests, cid), cid, 'drop_result_stmt')
                    if (len(failure) > 0):
                        resultShuttle.result_proof[0] = None

                logger.info("Replying to retransmit request from cid = %d and requestIndex = %d from resultCache" % (cid, requestIndex))
                send(('client_retransmit_response', resultShuttle.result, resultShuttle.result_proof, resultShuttle.requestIndex), to=resultShuttle.client)
                retransmitCache[(cid, requestIndex)] = 'Responded'
                send(('head_responded_to_retransmit',cid, requestIndex), to=replicas)
                return

            # wait for result shuttle to come back and then response
            elif (cid, requestIndex) in requestCache.keys():

                logger.info("Waiting for result shuttle to Reply to retransmit request from cid = %d and requestIndex = %d" % (cid, requestIndex))
                
                if await(some(received(('result_shuttle', resultShuttle)), has = resultShuttle.cid == cid and resultShuttle.requestIndex == requestIndex)):

                    time.sleep(0.1)

                    resultShuttle = resultShuttleCache.get((cid, requestIndex), None);

                    # change result if applicable
                    failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid),
                                                  cid, 'change_result')
                    if (len(failure) > 0):
                        resultShuttle.result = Failure.change_result()

                    # change opArgs if failure case demands
                    failure = Failure.get_failure(failures, 'forwarded_request',
                                                  self.get(self.client_forward_requests, cid), cid, 'drop_result_stmt')
                    if (len(failure) > 0):
                        resultShuttle.result_proof[0] = None

                    logger.info("Head responding, waiting for result shuttle for the operation in queue for cid = %d and requestIndex = %d" % (cid, requestIndex))
                    send(('client_retransmit_response', resultShuttle.result, resultShuttle.result_proof, resultShuttle.requestIndex), to=resultShuttle.client)
                    retransmitCache[(cid, requestIndex)] = 'Responded'
                    send(('head_responded_to_retransmit',cid, requestIndex), to=replicas)

                elif timeout(head_timeout):
                    logger.error("Reconfigure: head timed out waiting for result shuttle for the operation in queue for cid = %d and requestIndex = %d" % (cid, requestIndex))

            
            # unrecognized operation
            else:
               
                logger.info("Creating shuttle for unrecognized retransmit request from cid = %d and requestIndex = %d" % (cid, requestIndex))
                
                self.slot_number = self.slot_number + 1;

                # change opArgs if failure case demands
                failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid), cid, 'change_operation')
                if(len(failure) > 0):
                    opArgs = Failure.change_operation()

                # store received operations in the cache
                requestCache[(cid, requestIndex)] = opArgs

                shuttle = Shuttle(self.slot_number, opArgs, p, cid, requestIndex)

                result = Operation.do_op(dictionary, opArgs)

                # change result if applicable
                failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid), cid, 'change_result')
                if (len(failure) > 0):
                    result = Failure.change_result()

                orderStatement = creatSignedOrderStatement(self.slot_number, opArgs)
                shuttle.order_proof.append(orderStatement)

                resultStatement = creatSignedResultStatement(opArgs, result)
                shuttle.result_proof.append(resultStatement)

                # change opArgs if failure case demands
                failure = Failure.get_failure(failures, 'forwarded_request', self.get(self.client_forward_requests, cid), cid, 'drop_result_stmt')
                if (len(failure) > 0):
                    shuttle.result_proof[0] = None

                logger.info("Shuttle Started\t\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(shuttle.cid, shuttle.requestIndex,shuttle.slot_number))
                send(('shuttle', shuttle), to=nextr)

                self.incr(self.client_requests, cid)
                 
                logger.info("Waiting on result_shuttle on newly created request for cid = %d requestIndex = %d from rid = %d" % (cid, requestIndex, sourceRid))
                if await(some(received(('result_shuttle', resultShuttle)),has = resultShuttle.cid == cid and resultShuttle.requestIndex == requestIndex)):
                    time.sleep(0.1)
                    resultShuttle = resultShuttleCache.get((cid, requestIndex), None);
                    logger.info("result_shuttle on newly created request has arrived for cid = %d requestIndex = %d from rid = %d" % (cid, requestIndex, sourceRid))

                    send(('client_retransmit_response', resultShuttle.result, resultShuttle.result_proof, resultShuttle.requestIndex), to=resultShuttle.client)
                    
                    #mark retransmission complete though we don't use this value anymore
                    retransmitCache[(cid, requestIndex)] = 'Responded'

                    send(('head_responded_to_retransmit',cid, requestIndex), to=replicas)

                elif timeout(head_timeout):
                    logger.error("Reconfigure: head timeout waiting for result_shuttle on newly created request cid = %d requestIndex = %d from rid = %d" % (cid, requestIndex, sourceRid))



    def receive(msg=('shuttle', shuttle), from_=p):
        logger.info("Shuttle Received\t\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(shuttle.cid, shuttle.requestIndex,shuttle.slot_number))

        if not isOrderProofValid(shuttle.slot_number, shuttle.opArgs, shuttle.order_proof):
            logger.error("Reconfigure: Order Proof is not valid cid = %d requestIndex = %d slot_number = %d" % (shuttle.cid, shuttle.requestIndex, shuttle.slot_number))
            # send wedged statement to olympus
            return
         
        # change opArgs if failure case demands
        failure = Failure.get_failure(failures, 'shuttle', self.get(self.shuttle_requests, shuttle.cid), shuttle.cid,
                                      'change_operation')
        if (len(failure) > 0):
            shuttle.opArgs = Failure.change_operation()
         
        # store received operations in the cache
        requestCache[(shuttle.cid, shuttle.requestIndex)] = shuttle.opArgs

        self.slot_number = self.slot_number + 1;
        result = Operation.do_op(dictionary, shuttle.opArgs)

        # change result if applicable
        failure = Failure.get_failure(failures, 'shuttle', self.get(self.shuttle_requests, shuttle.cid), shuttle.cid,
                                      'change_result')
        if (len(failure) > 0):
            result = Failure.change_result()

        orderStatement = creatSignedOrderStatement(self.slot_number, shuttle.opArgs)
        shuttle.order_proof.append(orderStatement)

        resultStatement = creatSignedResultStatement(shuttle.opArgs, result)
        shuttle.result_proof.append(resultStatement)

        # change opArgs if failure case demands
        failure = Failure.get_failure(failures, 'shuttle', self.get(self.shuttle_requests, shuttle.cid), shuttle.cid,
                                      'drop_result_stmt')
        if (len(failure) > 0):
            shuttle.result_proof[0] = None

        if (nextr):
            logger.info("Shuttle Forwarded\t\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(shuttle.cid, shuttle.requestIndex,shuttle.slot_number))
            send(('shuttle', shuttle), to=nextr)
        else:
            logger.info("Client Response sent to cid = %d" % shuttle.cid)
            send(('client_response', result, shuttle.result_proof, shuttle.requestIndex), to=shuttle.client)
            
            resultShuttle = ResultShuttle(shuttle, result)

            if not isvalidResultProof(shuttle.opArgs, resultShuttle.result, resultShuttle.result_proof, self.public_keys):
                logger.error("Reconfigure: Result Proof is not valid for cid = %d requestIndex = %d" % (resultShuttle.cid, resultShuttle.requestIndex))
                return

            #store in the cache
            resultShuttleCache[(resultShuttle.cid, resultShuttle.requestIndex)] = resultShuttle


            failure = Failure.get_failure(failures, 'result_shuttle',
                                          self.get(self.result_shuttle_requests, resultShuttle.cid), resultShuttle.cid,
                                          'change_result')
            if (len(failure) > 0):
                resultShuttle.result = Failure.change_result()


            failure = Failure.get_failure(failures, 'result_shuttle',
                                          self.get(self.result_shuttle_requests, resultShuttle.cid), resultShuttle.cid,
                                          'drop_result_stmt')
            if (len(failure) > 0):
                resultShuttle.result_proof[0] = None


            logger.info("Result Shuttle Started\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(resultShuttle.cid, resultShuttle.requestIndex,resultShuttle.slot_number))

            send(('result_shuttle', resultShuttle), to=prevr)

            self.incr(self.result_shuttle_requests, resultShuttle.cid)
        
        self.incr(self.shuttle_requests, shuttle.cid)




    def receive(msg=('result_shuttle', resultShuttle), from_=p):
        logger.info("Result Shuttle Received\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(resultShuttle.cid, resultShuttle.requestIndex,resultShuttle.slot_number))
        
        if not isvalidResultProof(resultShuttle.opArgs, resultShuttle.result, resultShuttle.result_proof, self.public_keys):
            logger.error("Reconfigure: Result Proof is not valid for cid = %d requestIndex = %d" % (resultShuttle.cid, resultShuttle.requestIndex))
            return

        #cache the result shuttle
        resultShuttleCache[(resultShuttle.cid, resultShuttle.requestIndex)] = resultShuttle

        failure = Failure.get_failure(failures, 'result_shuttle', self.get(self.result_shuttle_requests,
                                                   resultShuttle.cid), resultShuttle.cid, 'change_result')
        if (len(failure) > 0):
            resultShuttle.result = Failure.change_result()



        failure = Failure.get_failure(failures, 'result_shuttle',
                                      self.get(self.result_shuttle_requests, resultShuttle.cid), resultShuttle.cid, 'drop_result_stmt')
        if (len(failure) > 0):
            resultShuttle.result_proof[0] = None


        if (prevr):
            logger.info("Result Shuttle Forwarded\t\t\t\t\t\t\tfor cid = %d and requestIndex=%d slot_number=%d" %(resultShuttle.cid, resultShuttle.requestIndex,resultShuttle.slot_number))

            send(('result_shuttle', resultShuttle), to=prevr)

        self.incr(self.result_shuttle_requests, resultShuttle.cid)



    def receive(msg=('shutdown',), from_=p):
        logger.info("Request for shutdown")
        send(('shut', str(ReplicaState(self.rid, self.dictionary))), to=p)
        self.on = False
