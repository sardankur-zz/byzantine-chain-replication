import sys
import time
import re
import json

common = import_da("common")
Operation = common.Operation
get_logger = import_da("app_logging").get_logger
Olympus = import_da("olympus").Olympus
Client = import_da("client").Client


logger = get_logger("MAIN")

def read_configuration(filename):
    logger.info("Reading Test Configuration")
    test_config = {}
    with open(filename, 'r') as f:
        for line in f:
            if line[0] != '#':
                (key, sep, val) = line.partition('=')
                if len(sep) != 0:
                    val = val.strip()
                    test_config[key.strip()] = int(val) if str.isdecimal(val) else val
    return test_config

def main():

    if(len(sys.argv) != 2):
        logger.error("Number or arguments is incorrect")
        exit(1)

    test_config = read_configuration(sys.argv[1])

    # read failure cases
    failures = {}
    for key in test_config.keys():
        if key[:8] == "failures":
            c, r = key[8:][:-1][1:].split(",")
            failures[c] = failures.get(c, {})
            failures[c][r] = failures[c].get(r, [])
            failure_op = test_config[key].split(";")
            for op in failure_op:
                trigger, failure = op.split("),")
                failure = failure[:-2]
                trigger, args = trigger.split("(")
                arg1, arg2 = args.split(",")
                formatted_op = [(trigger.strip(), arg1.strip(), arg2.strip()), failure.strip()]
                failures[c][r].append(formatted_op)

    # start olympus
    olympus = new(Olympus, [test_config['head_timeout'], test_config['nonhead_timeout'], test_config['t'], failures], num=1)
    start(olympus)

    # TODO add sleep here
    # await(timeout(1))

    send(('init',), to=olympus)
    # Wait for reconfiguration

    # start clients
    clients = list(new(Client, num = test_config['num_client']))
    for i in range(len(clients)):
        setup(clients[i], (i, test_config['client_timeout'], olympus))
    start(set(clients))

    for i in range(len(clients)):
        workload_string = test_config['workload['+str(i)+']'];
        workload_lines = workload_string.split(';')
        opSequence = []
        for line in workload_lines:
            line = line.replace("'", "")
            words = re.split('[(),]+',line.strip())
            opSequence.append(words[:-1])

        if opSequence[0][0] == 'pseudorandom':
            opSequence = Operation.generate_requests(int(opSequence[0][1]), int(opSequence[0][2]))

        index = 0
        while index < len(opSequence):
            nextIndex = min(index + 100, len(opSequence))
            clk = logical_clock()
            send(('client_workload', opSequence[index:nextIndex]))
            await(some()
            index = nextIndex

    time.sleep(0.2)

    # waiting for clients to finish their workload
    await(each(c in clients, has=received(('shut',), from_=c)))
    logger.info("Clients are shut")

    send(("shutdown",), to=olympus)

    if await(len(setof(p, received(('shut', replica_state), from_=p))) == 1):
        replica_states = setof(replica_state, received(('shut', replica_state), from_=p))
        replica_states = json.loads(next(iter(replica_states)))
        if 'test_workload' in test_config.keys():
            for i, item in enumerate(replica_states):
                if test_config['test_workload'] != str(item['dictionary']):
                    logger.error("Replica rid=%d in inconsistent state = %s" % (item['rid'], item['dictionary']))
                else:
                    logger.info("Replica rid=%d in consistent state = %s" % (item['rid'], item['dictionary']))

        # check validity for each test case
    elif timeout(test_config['client_timeout']):
        logger.error("Timeout from olympus")

    logger.info("Olympus is shut")
