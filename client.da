from enum import Enum
from nacl.bindings.utils import sodium_memcmp
import logging
import nacl.signing
import nacl.hash
import nacl.encoding

HASHER = nacl.hash.sha256
get_logger = import_da("app_logging").get_logger
common = import_da("common")
OpArgs = common.OpArgs

logger = get_logger("CLIENT")

class Client(process):

    def setup(cid: int, client_timeout: int, olympus):
        self.latest_config = None
        self.on = True
        self.workArgs = []
        self.requestIndex = 0
        self.main_client = None

        formatter = logging.Formatter("%(asctime)s : %(levelname)s : %(name)s " + str(self.cid) + " : %(message)s")
        for handler in logger.handlers:
            handler.setFormatter(formatter)

        logger.info("Initialized with Workload : %s" % (str(self.workArgs)))

    
    def isvalidResultProof(opArgs, result, result_proof, public_keys):
        result_hash = HASHER(result.encode(encoding='UTF-8'), encoder=nacl.encoding.HexEncoder)
        i = 0

        for resultStatement in result_proof:
            if resultStatement is None:
                logger.debug("Result statement number = %d is missing" % i)
                return False   
            if opArgs != resultStatement.operation:
                logger.debug("opArgs for Result statement number = %d is not valid" % i)
                return False         
            if not sodium_memcmp(resultStatement.result_hash, result_hash):
                logger.debug("Result Hash for Result statement number = %d is not valid" % i)
                return False

            try:
                public_keys[i].verify(resultStatement.signature)
            except Exception:
                logger.debug("Result Statement number = %d is tempered" % i)
                return False
            i = i + 1

        return True 


    def run():
        logger.info("Running")
        await(self.on == False)
        send(('shut',), to=self.main_client)
        logger.info("Terminated")


    def receive(msg=('client_workload', workload), from_=p):
        for work in workload:
            if(len(work) < 3):
                self.workArgs.append(OpArgs(work[0], work[1]))
            else:
                self.workArgs.append(OpArgs(work[0], work[1], work[2]))
        send(('client_workload_ack',), to=p)


    def receive(msg=('client_run'), from_=p):
        for requestIndex in range(len(self.workArgs)):
            send(('latest_configuration',), to=olympus)
            await(some(received(('latest_configuration', config)), has=config is not None))
            self.latest_config = config
            send(('client_request', workArgs[requestIndex], cid, requestIndex), to=self.latest_config.head)

            if (await(some(received(('client_response', result, result_proof, rIndex)), has=rIndex == requestIndex))):
                if not isvalidResultProof(workArgs[requestIndex], result, result_proof, config.public_keys):
                    logger.error("Result Proof is not valid for rIndex = %d" % rIndex)
                    continue  # TODO:report to the olympus
                else:
                    continue

            elif timeout(self.client_timeout / 1000):
                log.info("Request number : %d retransmitting" % requestIndex)
                send(('client_retransmit_request', workArgs[requestIndex], cid, requestIndex),
                     to=self.latest_config.replicas)
                if (await(some(received(('client_retransmit_response', result, result_proof, rIndex)),
                               has=rIndex == requestIndex))):
                    pass
                elif timeout(self.client_timeout / 1000):
                    log.error("Request number : %d response timed out", requestIndex)
                    log.error("Reconfigure")

        self.on = False




