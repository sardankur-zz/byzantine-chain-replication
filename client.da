import logging

from enum import Enum
get_logger = import_da("app_logging").get_logger
common = import_da("common")
OpArgs = common.OpArgs

logger = get_logger("CLIENT")


class ClientMode(Enum):
    ACTIVE = 0
    AWAITING = 1
    KILLED = 2

class Client(process):

    def setup(cid: int, client_timeout: int, workload:list, olympus):
        self.latest_config = None
        self.mode = ClientMode.ACTIVE
        self.workArgs = []
        self.workIndex = 0

        formatter = logging.Formatter("%(asctime)s : %(levelname)s : %(name)s " + str(self.cid) + " : %(message)s")
        for handler in logger.handlers:
            handler.setFormatter(formatter)

        for work in workload:
            if(len(work) < 3):
                self.workArgs.append(OpArgs(work[0], work[1]))
            else:
                self.workArgs.append(OpArgs(work[0], work[1], work[2]))  

        logger.info("Initialized with Workload : %s" % (str(self.workArgs)))

    def run():
        logger.info("Running")
        #send(('client_request', workArgs[workIndex]), to=self.latest_config.head)
        workIndex += 1
        await(self.mode == ClientMode.KILLED)
        logger.info("Terminated")

    def receive(msg=('client_request', opArgs)):
        send(('latest_configuration',), to=olympus)
        await(some(received(('latest_configuration', config)), has=config is not None))
        self.latest_config = config
        if workIndex < len(workArgs):
            send(('client_request', workArgs[workIndex]), to=self.latest_config.head)
            workIndex += 1
        if(await(received(('client_response',)))):
            pass
        elif timeout(self.client_timeout):
            # what to do?
            pass



    def receive(msg=("shutdown",), from_=p):
        logger.info("Request for shutdown")
        send(('shut',), to=p)
        self.mode = ClientMode.KILLED
